"{-# LANGUAGE Arrows #-}\n\nmodule Helpers.States.WallFollowState where\n\nimport Control.Concurrent\nimport FRP.Yampa\nimport Helpers.Turtlebot\nimport Helpers.KeyboardController\nimport Helpers.YampaHelper\n\nwallFollowSF :: SF String (Double, Double, Bool, String)\nwallFollowSF = proc inputStr -> do\n  -- Decode turtlebot for string\n  let (turtlebot, turtlebotErrFlag, turtlebotDebugMsg) = decodeTurtlebotState inputStr\n  let (keyboardcontroller, keyboardcontrollerErrFlag, keyboardcontrollerDebugMsg) = decodeKeyboardControllerState inputStr\n\n  -- #### Control logic ####\n\n  -- #### END: Control logic ####\n\n  -- Create the error string\n  let (errFlag, debugMsg) = createErrFlagAndDebugMsg [(\"turtlebot\", turtlebotErrFlag, turtlebotDebugMsg),(\"keyboardController\", keyboardcontrollerErrFlag, keyboardcontrollerDebugMsg)]\n  -- Add your own values for debugging\n  let specialDebugString = if errFlag then \"DEBUG:: \" ++ debugMsg else \"STATE: WallFollow :: \"\n  -- To stop simulation\n  let debugString\n        | quit keyboardcontroller || errFlag = \"STOPSIM \" ++ specialDebugString\n        | otherwise = specialDebugString\n\n  returnA -< (leftWheelVelocityInRadSec,rightWheelVelocityInRadSec,errFlag,debugString)\n\nanalyzerWallFollowState :: SF (String, (Double, Double, Bool, String)) (Event (String))\nanalyzerWallFollowState = proc (sfInput, sfOutput) -> do\n  e <- edgeTag \"newStateName\" -< True \n  returnA -< \"\""