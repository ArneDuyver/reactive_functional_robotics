{-# LANGUAGE Arrows #-}

module Helpers.States.{{moduleName}}State where

import Control.Concurrent
import FRP.Yampa
import Helpers.YampaHelper
{{import_controllers}}
import Helpers.States.StateTemplate

-- Use the generic wrappers
{{stateNameLower}}StateSF :: SF String OutputState
{{stateNameLower}}StateSF = genericStateSF "{{stateName}}" stateBehaviour

analyzer{{stateName}}State :: SF (String, OutputState) (Event String)
analyzer{{stateName}}State = genericAnalyzerSF stateTransition


-- Specific behaviour for {{stateName}}
stateBehaviour :: SF {{sf_input_type}} ({{output_type}}, String)
stateBehaviour = proc {{sf_input_parameter}} -> do
  -- Create default types for Output
  let {{output_variable}} = {{default_output}}
      debugString = "STATE: {{stateNameLower}} :: "  -- Customize this debug message
      -- Add your control logic here using the input parameters
  returnA -< ({{output_variable}}, debugString)

-- Specific transition for {{stateName}}
stateTransition :: SF {{sf_input_type}} (Bool, String)
stateTransition = proc {{sf_input_parameter}} -> do
  -- Add your transition logic here using the input parameters:
  -- Return (shouldSwitch, targetStateName)
  let shouldSwitch = False  -- Change this condition based on your logic
      targetState = "newStateName"  -- Target state name
      -- Add your transition logic here based on the input parameters
  returnA -< (shouldSwitch, targetState)